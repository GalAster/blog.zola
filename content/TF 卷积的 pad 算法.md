+++
title = "TF 卷积的 pad 算法"
date = 2019-10-06
[taxonomies]
+++

<p>二、tf的padding有两个值，一个是SAME，一个是VALID</p><p>以下展示卷积三种模式的不同之处</p><p>其实这三种不同模式是对卷积核移动范围的不同限制。设 image的大小是7x7，filter的大小是3x3。</p><h2>Valid Mode</h2><img src="https://pic4.zhimg.com/v2-3a0dcec25b7e92e35b47141b725bb80f_b.jpg"><p><b>当filter全部在image里面的时候，进行卷积运算</b>，可见filter的移动范围较same更小了。</p><ul><li><p><b>输入图片大小</b>: W*W</p></li><li><p><b>Filter大小</b>:</p></li><li><p><b>步长</b>: S</p></li><li><p><b>padding的像素数</b>: p</p></li></ul><p>N = (<i>W- F</i>+ 2<i>P</i>)/<i>S</i>+1</p><p>输出大小为N<i>N</i></p><p>如果padding设置为SAME，则说明输入图片大小和输出图片大小是一致的，如果是VALID则图片经过滤波器后可能会变小。</p><p><b>padding = "VALID"输入和输出大小关系如下：</b></p><p class="math">$$n_{\text {output}}=\left[\frac{n_{\text {input}}-f+1}{s}\right]$$</p> <p>conv2d的VALID方式不会在原有输入的基础上添加新的像素（假定我们的输入是图片数据，因为只有图片才有像素），输出矩阵的大小直接按照公式计算即可。</p><h2>Same Mode</h2><img src="https://pic4.zhimg.com/v2-080521c3a55393fb3f4d90c92eeb744b_b.jpg"><p><b>当filter的中心(K)与image的边角重合时，开始做卷积运算</b>，可见filter的运动范围比full模式小了一圈。注意：这里的same还有一个意思，卷积之后输出的feature map尺寸保持不变(相对于输入图片)。当然，same模式不代表完全输入输出尺寸一样，也跟卷积核的步长有关系。same模式也是最常见的模式，因为这种模式可以在前向传播的过程中让特征图的大小保持不变，调参师不需要精准计算其尺寸变化(因为尺寸根本就没变化)。</p><p><b>padding = "SAME"</b>输入和输出大小关系如下<b>：</b>输出大小等于输入大小除以步长向上取整</p><p class="math">$$n_{\text {output}}=\left[\frac{n_{\text {input}}}{s}\right]$$</p> <p>在高度上需要pad的像素数为：</br>pad_needed_height = (new_height [Dash] 1) * S + F - W</p><p>根据上式，输入矩阵上方添加的像素数为：</br>pad_top = pad_needed_height / 2 （结果取整）</p><p>下方添加的像素数为：</br>pad_down = pad_needed_height - pad_top</p><p>以此类推，在宽度上需要pad的像素数和左右分别添加的像素数为</br>pad_needed_width = (new_width [Dash] 1) * S + F - W</br>pad_left = pad_needed_width / 2 （结果取整）</br>pad_right = pad_needed_width [Dash] pad_left</p><h2>Full Mode</h2><img src="https://pic4.zhimg.com/v2-1e4dd2f22ad884ef8b142869dfe19d6b_b.jpg"><p>橙色部分为image, 蓝色部分为filter。full模式的意思是，<b>从filter和image刚相交开始做卷积，</b>白色部分为填0。filter的运动范围如图所示。</p>
